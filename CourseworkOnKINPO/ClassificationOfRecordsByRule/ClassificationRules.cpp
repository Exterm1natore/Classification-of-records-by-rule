/*!
*\file
*\brief Данный  файл содержит в себе реализацию основных функций класса ClassificationRules, которые используются в программе.
*/

#include "ClassificationRules.h"

ClassificationRules::ClassificationRules()
{
    name = "";
    constraint = "";
}

void ClassificationRules::splitStringOfClassificationRules(const QString& rulesData, QList<ClassificationRules>* classificationRules)
{
    ClassificationRules checkRules; // создаём переменную класса ClassificationRules

    // запускаем функцию по проверке текста правил классификации
    checkRules.checkClassificationRules(rulesData);

    // делим текст правил классификации по символу точка с запятой (';')
    QStringList substringsRules = rulesData.split(";");

    // Для каждой строки поделённого текста
    for(int i = 0; i < substringsRules.count(); i++)
    {
        ClassificationRules newRule; // создаём переменную класса ClassificationRules
        QRegExp classRx("\"([^\"]+)\""); // регулярное выражение для поиска слов внутри двойных кавычек (' " ')
        QRegExp propertyRx("свойство \"([^\"]+)\""); // регулярное выражение для слов после слова "свойство \"" и до закрывающей двойной кавычки
        int classPos = classRx.indexIn(substringsRules[i]); // получаем индекс первых двух двойных кавычек

        // Если регулярное выражение нашло слово
        if (classPos != -1)
        {
            // записываем название класса
            newRule.name = classRx.cap(1);
        }

        int propertyPos = propertyRx.indexIn(substringsRules[i]); // получаем индекс следующих двух двойных кавычек

        // Если регулярное выражение нашло слово
        if (propertyPos != -1)
        {
            // записываем название текстового ограничения
            newRule.constraint = propertyRx.cap(1);
        }

        // создаём строку, соответствующую правилу с дополнительным ограничением в виде количества целочисленных значений
        QString withLength = "которое представлено";

        // создаём строку, соответствующую правилу с дополнительным ограничением в виде одного целочисленного значения
        QString singleValue = "в составе которого есть значение";

        // создаём строку, соответствующую правилу с дополнительным ограничением в виде массива целочисленных значений
        QString severalValues = "и значение этого свойства равно";

        // Если строка соответствует правилу с дополнительным ограничением в виде количества целочисленных значений
        if(substringsRules[i].contains(withLength))
        {
            // устанавливаем тип правила с количеством целочисленных значений
            newRule.condition = propertyWithLength;

            // Если есть слово "одним"
            if(substringsRules[i].contains("одним"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Single;
            }

            // Если есть слово "двумя"
            else if(substringsRules[i].contains("двумя"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Two;
            }

            // Если есть слово "тремя"
            else if(substringsRules[i].contains("тремя"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Three;
            }

            // Если есть слово "четырьмя"
            else if(substringsRules[i].contains("четырьмя"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Four;
            }

            // Если есть слово "пятью"
            else if(substringsRules[i].contains("пятью"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Five;
            }

            // Если есть слово "шестью"
            else if(substringsRules[i].contains("шестью"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Six;
            }

            // Если есть слово "семью"
            else if(substringsRules[i].contains("семью"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Seven;
            }

            // Если есть слово "восемью"
            else if(substringsRules[i].contains("восемью"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Eight;
            }

            // Если есть слово "девятью"
            else if(substringsRules[i].contains("девятью"))
            {
                // записываем в emun соответствующее значение
                newRule.limitValue = Nine;
            }
        }

        // Иначе если строка соответствует правилу с дополнительным ограничением в виде одного целочисленного значения
        else if(substringsRules[i].contains(singleValue))
        {
            newRule.condition = propertySingleValue; // устанавливаем тип правила с одним целочисленным значением
            newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста
            QRegExp rxValue("(\\d+)"); // создаём регулярное выражение, которое ищет последовательность одной или более цифр в тексте
            int pos = 0; // создаём переменную равную позиции цифр в тексте

            // Пока есть числа в тексте
            while ((pos = rxValue.indexIn(substringsRules[i], pos)) != -1)
            {
                newRule.integerValues.append(rxValue.cap(1).toInt()); // записываем число в контейнер целочисленных значений
                pos += rxValue.matchedLength(); // ищем следующие цифры в строке
            }
        }

        // Иначе если строка соответствует правилу с дополнительным ограничением в виде массива целочисленных значений
        else if(substringsRules[i].contains(severalValues))
        {
            newRule.condition = propertyWithSeveralValues; // устанавливаем тип правила с массивом целочисленных значений
            newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста

            int start = substringsRules[i].indexOf('['); // ищем первый символ '['
            int end = substringsRules[i].indexOf(']'); // ищем первый символ ']'
            QString substring = substringsRules[i].mid(start + 1, end - start - 1); // вырезаем подстроку между скобками
            QStringList values = substring.split(",", QString::SkipEmptyParts); // разделяем подстроку по запятой

            // Для каждого числа в строке
            for (const QString& value : values)
            {
                bool ok; // флаг, указывающий на удачноть преобразования подстроки в int
                int intValue = value.trimmed().toInt(&ok); // преобразуем строку в целое число

                // Если подстрока успешно преобразована
                if (ok)
                {
                    // записываем число в контейнер целочисленных значений
                    newRule.integerValues.append(intValue);
                }
            }
        }

        // Иначе
        else
        {
            newRule.condition = propertyWithNoValue; // устанавливаем тип правила без дополнительного ограничения
            newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста
        }

        classificationRules->append(newRule); // записываем полученные значения текущей строки в контейнер класса ClassificationRules
    }
}

void ClassificationRules::checkClassificationRules(const QString& strRule)
{
    // Паттерн для проверки первого типа строки
    QString pattern1 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\"";

    // Паттерн для проверки второго типа строки
    QString pattern2 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\", которое представлено (одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью) значени";

    // Паттерн для проверки третьего типа строки
    QString pattern3 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\", в составе которого есть значение \"(.+)\"";

    // Паттерн для проверки четвёртого типа строки
    QString pattern4 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\" и значение этого свойства равно \"\\[(.+)\\]\"";

    // Регулярное выражение четвёрного паттерна
    QRegularExpression regex1(pattern4);

    // Регулярное выражение третьего паттерна
    QRegularExpression regex2(pattern3);

    // Регулярное выражение второго паттерна
    QRegularExpression regex3(pattern2);

    // Регулярное выражение первого паттерна
    QRegularExpression regex4(pattern1);

    QString emptyStr = strRule.trimmed(); // удаляем начальные и конечные пробелы во входной строке

    // Если входной текст правил классификации является пустым
    if(emptyStr.isEmpty())
    {
        // вызываем исключение "Ошибка! Файл с входными данными правил классификации является пустым."
        throw QString ("Текст правил классификации:\nОшибка! Файл с входными данными правил классификации является пустым.");
    }

    // Если входной текст правил классификации не заканчивается точкой вызываем исключение
    if (!strRule.endsWith("."))
    {
        // вызываем исключение "Ошибка! В конце текста правил классификации должна стоять точка ('.')."
        throw QString ("Текст правил классификации:\nОшибка! В конце текста правил классификации должна стоять точка ('.').");
    }

    // Если в тексте правил классификации больше одной точки - вернуть ошибку
    if (strRule.count(".") > 1)
    {
        /* вызываем исключение о том, что в конце текста правил должна находиться только 1 точки и при этом в конце и выводим номер символа
        ошибки в тексте*/
        throw QString ("Текст правил классификации:\nОшибка! В тексте правил классификации может быть только одна точка ('.'), которая должна находится после последнего правила."
                       "\nНомер ошибочного символа в тексте с правилами классификации: " + QString::number(strRule.indexOf(".") + 1));
    }

    // разделить текст правил по символу разделения правил классификации - точки с запятой
    const QStringList& strOneRule = strRule.split(";", QString::SkipEmptyParts);

    // Вернуть ошибку, если количество правил классификации превышает 100
    if(strOneRule.count() > 100)
    {
        // вызываем исключение о том что количество правил больше 100
        throw QString ("Текст правил классификации:\nОшибка! Количество записей не должно превышать 100. Допустимый диапазон: [1;100].");
    }

    // контейнер для хранения названий классов, для последующего сравнения и поиска совпадений
    QList<QString> numberRuleName;

    // Для каждого правила (правила разделены символом ';')
    for(int i = 0; i < strOneRule.count(); i++)
    {
        /* Если слово 'нее' в правиле было написано сечерез 'ё' (проверка имеет смысл, т.к. ошибка частая и чтобы конкретезиовать её тип
         есть смысл выделить в отдельную проверку)*/
        if(strOneRule[i].contains("если у неё есть свойство"))
        {
            // вызываем исключение о том что слово нее написано через ё и выводим ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Слово \'неё\' можно писать только через \'е\'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
        }

        // Если правило не заканчивается на ' " ', '.', 'и' или 'м' (то есть правило имееет неверный формат)
        if(strOneRule[i][strOneRule[i].count() - 1] != "\"" && strOneRule[i][strOneRule[i].count() - 1] != "."
                && strOneRule[i][strOneRule[i].count() - 1] != "и" && strOneRule[i][strOneRule[i].count() - 1] != "м")
        {
            // вызываем исключение которое показываем правильные форматы ввода правил и ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода. Правило должно заканчиваться на следующие символы ('\" или '.' или 'и' или 'м')"
                           ", в зависимости от типа правила."
                           "\nПроверьте правильность постановки точки с запятой \';\'."
                           "\nОшибка в тексте правила " + QString::number(i + 1) + ": " + strOneRule[i] +
                           ";\n\nДопустимые форматы: "
                           "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                           "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                           "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                           "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
        }

        /* Если правило начинается не с указанного формата, а с пробела (то же довольно частая ошибка,
          есть смысл выделить в отдельную проверку)*/
        if(strOneRule[i][0].isSpace())
        {
            // вызываем исключение что правило не может начинаться с пробела и выводим ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Правило не может начинаться с пробела."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
        }

        // Для каждого символа текущего правила
        for(int j = 0; j < strOneRule[i].count() - 1; j++)
        {
            // Если встретилось 2 пробела подряд
            if(strOneRule[i][j].isSpace() && strOneRule[i][j + 1].isSpace())
            {
                QString errTXT = strOneRule[i]; // создаём строку и присваиваем значение текущей строки правил
                errTXT.replace(" ", "*", Qt::CaseInsensitive); //меняем для наглядности все пробелы звёздочками (*)

                // вызываем исключение о том, что нельзя использовать 2 пробела подряд и ошибочную строку где вместо пробела символ '*'
                throw QString ("Текст правил классификации:\nОшибка! В тексте правила не допускается использовать больше одного пробела подряд."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + errTXT);
            }
        }

        // Проверка что правила классификации не разделены символом точкой с запятой (частая ошибка, выделяем в отдельную проверку)
        if(strOneRule[i].count("\"") != 4 && strOneRule[i].count("\"") != 6 && strOneRule[i].count("Запись принадлежит классу") > 1)
        {
            // вызываем исключение о том, что правила классификации должны разделяться символом ';' и выводим ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Правила классификации должны быть разделены точкой с запятой \';\'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
        }

        // Проверка что в правиле стоит 4 или 6 двойных кавычек ' " ' (общая проверка на лишние символы)
        else if (strOneRule[i].count("\"") != 4 && strOneRule[i].count("\"") != 6)
        {
            // вызываем исключение о том что в правиле должно быть либо 4 либо 6 кавычек и ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! В правиле должно быть либо 4, либо 6 двойных кавычек ('\"') в зависимости от типа правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
        }

        // Проверка что текст правила начинается с указанного формата и перед ним не стоят другие символы
        if(!strOneRule[i].startsWith("Запись принадлежит классу") || strOneRule[i].count("Запись принадлежит классу") != 1)
        {
            // вызываем исключение о том, какие форматы правил должны быть и ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                           "\n\nДопустимые форматы: "
                           "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                           "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                           "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                           "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
        }

        // Если правило подходит хотя бы под один из указанных паттернов
        if(regex1.match(strOneRule[i]).hasMatch() || regex2.match(strOneRule[i]).hasMatch()
                || regex3.match(strOneRule[i]).hasMatch() || regex4.match(strOneRule[i]).hasMatch())
        {
            // хранение текста между двойными кавычками текущего правила
            QStringList substrings;

            // позиция первых двойных кавычек в правиле
            int startPos = strOneRule[i].indexOf("\"");

            // Пока есть двойные кавычки
            while (startPos != -1)
            {
                // Получение индекса следующей двойной кавычки после текущей двойной кавычки
                int endPos = strOneRule[i].indexOf("\"", startPos + 1);

                // Если не последняя двойная кавычка
                if (endPos != -1)
                {
                    // получение подстроки внутри двойных кавычек и передох к следующей паре двойных кавычек
                    QString substring = strOneRule[i].mid(startPos + 1, endPos - startPos - 1);
                    substrings.append(substring); // добавляем в массив подстоку
                    startPos = strOneRule[i].indexOf("\"", endPos + 1); // ищем следующую позицию двойных кавычек
                }

                // Иначе заканчиваем выполнение цикла
                else
                    break;
            }

            // Для каждой подстроки
            for(int j = 0; j < 2; j++)
            {
                // Если в названии класса или текстовом ограничении в начеле или в конце встречается не буква
                if(!substrings[j][0].isLetter() || !substrings[j][substrings[j].count() - 1].isLetter())
                {
                    /* вызываем исключение о том что начинаться или заканчиваться название класса текстового ограничения не с буквы не может
                       и выводим ошибочное правило*/
                    throw QString ("Текст правил классификации:\nОшибка! Внутри двойных кавычек ('\"') в названии класса и текстовом ограничении текст не может начинаться и заканчиваться не буквой."
                                   "\nВы ввели: " + substrings[j] +
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
            }

            // Провека, что название класса содержит от 3 до 20 символов
            if(substrings[0].count() < 3 || substrings[0].count() > 20)
            {
                // вызываем исключение о том что название класса не может быть меньше 3 или больше 20 символов и выводим ошибочное правило
                throw QString ("Текст правил классификации:\nОшибка! Название класса не может быть меньше трёх или больше двадцати символов."
                               "\nВы ввели: " + substrings[0] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
            }

            // Проверка что текстовое ограничение правила содержит от 3 до 20 символов
            if(substrings[1].count() < 3 || substrings[1].count() > 20)
            {
                // вызываем исключение о том что текстое ограничение не может быть меньше 3 или больше 20 символов и выводим ошибочное правило
                throw QString ("Текст правил классификации:\nОшибка! Текстовое ограничение правила не может быть меньше трёх или больше двадцати символов."
                               "\nВы ввели: " + substrings[1] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
            }

            // Проверка что название класса начинается с заглавной буквы
            if(!substrings[0][0].isUpper())
            {
                // вызываем исключение что название класса должно начинаться с заглавной буквы и выводим ошибочное правило
                throw QString ("Текст правил классификации:\nОшибка! Название класса должно начинаться с заглавной буквы."
                               "\nВы ввели: \"" + substrings[0] +
                        "\"\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
            }

            // Для каждого символа названия класса кроме первого
            for(int j = 1; j < substrings[0].count(); j++)
            {
                // Если текущий символ в названии класса не пробел и в верхнем регистре
                if(!substrings[0][j].isSpace() && substrings[0][j].isUpper())
                {
                    // вызываем исключение о том, что все кроме первой буквы должны быть в нижнем регистре и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! В названии класса все буквы, кроме первой, должны быть в нижнем регистре."
                                   "\nВы ввели: " + substrings[0] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
            }

            // Для каждого символа названия класса
            for(int j = 0; j < substrings[0].count(); j++)
            {
                // Если в названии класса есть не только буквы или пробелы
                if(!substrings[0][j].isLetter() && !substrings[0][j].isSpace())
                {
                    // вызываем исключение о том, что в названии класса могут быть только буквы ру или анг алфавита и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! В названии класса допускается использование только букв русского или английского алфавита "
                                   "и пробелов (не больше одного подряд)."
                                   "\nВы ввели: " + substrings[0] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
            }

            // Для каждого символа текстового ограничения
            for(int j = 0; j < substrings[1].count(); j++)
            {
                // Если в текстовом огарничении встречается не буква
                if(!substrings[1][j].isLetter())
                {
                    // вызываем исключение о том, что в текстовом ограничении могут быть только буквы рус или англ алфавита и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Текстовое ограничение может содержать только буквы русского или английского алфавита и не должно содержать пробелы."
                                   "\nВы ввели: " + substrings[1] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
            }

            // Если в текстовом ограничии встечается буква в верхнем регистре
            if(!substrings[1].isLower())
            {
                // вызываем исключение о том, что текстовое ограничение может содержать только буквы в нижнем регистре и выводим ошибочное правило
                throw QString ("Текст правил классификации:\nОшибка! Текстовое ограничение может содержать только буквы в нижнем регистре."
                               "\nВы ввели: " + substrings[1] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
            }

            // Если правило соответсвует формату 4 паттерна
            if (regex1.match(strOneRule[i]).hasMatch())
            {
                // Если в правиле соответствующего 4 паттерну не по одной квадратной скобке
                if(strOneRule[i].count("[") != 1 && strOneRule[i].count("]") != 1)
                {
                    // вызываем исключение о том что неверный формат правила и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nДанный тип правила должен содержать по одному символу '[' и ']'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если после правила есть лишние символы
                if(strOneRule[i].indexOf("]") + 2 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                {
                    // вызываем исключение о том что неверный формат правила и выводим ошибоное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nДанный тип правила должен заканчиваться на ']\"' (...]\")."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если после правила есть лишние символы
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].indexOf("]") + 2] != ".")
                {
                    // вызываем исключение о том что правило должно заканчиваться на ']".' и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nДанный тип правила должен заканчиваться на ']\".' (...]\".)."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                //---------------------------Болок проверки символов внутри квадратных скобок------------------------------------
                int checkStart = strOneRule[i].indexOf('['); // ищем первый символ '['
                int checkEnd = strOneRule[i].indexOf(']'); // ищем первый символ ']'

                // Если между квадратными скобками нет ничего
                if(checkEnd - checkStart == 1)
                {
                    // вызываем исключение о том, что поле между '[' ']' не должно быть пустыи и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nПоле между символами '[' и ']' не должно быть пустым."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если после символа '[' стоит не цифра
                if(!strOneRule[i][checkStart+ 1].isNumber())
                {
                    // вызываем исключение о том, что после '[' могут быть только цифры и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nНе допускается сразу после символа '[' использование чего-либо, кроме цифр."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если перед символом ']' стоит не цифра
                if(!strOneRule[i][checkEnd - 1].isNumber())
                {
                    // вызываем исключение о том, что перед ']' могут быть только цифры и выводим огибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nНе допускается сразу перед символом ']' использование чего-либо, кроме цифр."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                int position; // текущая позиция в строке
                position = checkStart + 1; // позиция должна начинаться со следующего символа после '['

                // Пока позиция в строке не равна ']'
                while(strOneRule[i][position] != "]")
                {
                    // Если между '[' ']' используется что-либо кроме цифр, пробела или запятой
                    if(!strOneRule[i][position].isNumber() && !strOneRule[i][position].isSpace() && strOneRule[i][position] != ",")
                    {
                        // выводим исключенеи о том, что между '[' ']' могут быть только цифры ',' и пробел и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                       "\nНе допускается использование между символами '[' и ']' всего, кроме 'пробела', ',' или цифр."
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    // Если между символами '[' ']' стоит больше одного пробела подряд
                    if(strOneRule[i][position].isSpace() && strOneRule[i][position + 1].isSpace())
                    {
                        // вызываем исключение о том, что между '[' ']' может быть только одиночный пробел и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                       "\nНе допускается между символами '[' и ']' использование больше одного 'пробела' подряд."
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    // Если между символами '[' ']' стоит больше одной запятой подряд
                    if(strOneRule[i][position] == "," && strOneRule[i][position + 1] == ",")
                    {
                        // вызываем исключение о том, что между '[' ']' может быть только одиночная запятая и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                       "\nНе допускается между символами '[' и ']' использование больше одной запятой (',') подряд."
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    // Если между символами '[' ']' стоит пробел и после него запятая
                    if(strOneRule[i][position].isSpace() && strOneRule[i][position + 1] == ",")
                    {
                        // вызываем исключение о том, что между '[' ']' нельзя использовать после пробела запятой и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                       "\nНе допускается между символами '[' и ']' использование после 'пробела' запятой (',')."
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    // Если следующий символ не ']' и после числа не стоит запятая
                    if(strOneRule[i][position + 1] != "]" && strOneRule[i][position].isNumber()
                            && !strOneRule[i][position + 1].isNumber() && strOneRule[i][position + 1] != ",")
                    {
                        // вызываем исключение о том, что между '[' ']' после числа должна стоять запятая и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                       "\nМежду символами '[' и ']' после числа должна стоять запятая (',')."
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    position ++; // Перейти к следующему символу
                }

                int start = strOneRule[i].indexOf('['); // ищем первый символ '['
                int end = strOneRule[i].indexOf(']'); // ищем первый символ ']'

                QString substring = strOneRule[i].mid(start + 1, end - start - 1); // вырезаем подстроку между скобками
                QStringList values = substring.split(",", QString::SkipEmptyParts); // разделяем подстроку по запятой
                int numberValues = 0; // количество чисел внутри '[' ']'

                // Для каждого числа между '[' ']'
                for (const QString& value : values)
                {
                    bool ok; // флаг преобразования подстроки в int
                    int intValue = value.trimmed().toInt(&ok); // преобразуем строку в целое число

                    // Если удалось преобразовать подстроку в целое число
                    if (ok)
                    {
                        // Если число не лежит в диапазоне от 1 до 99
                        if(intValue < 1 || intValue > 99)
                        {
                            // вызываем исключение о том, что числа должны быть в диапазоне от 1 до 99 и выодим ошибочное правило
                            throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                           "\nМежду символами '[' и ']' числа должны лежать в диапазоне [1;99]."
                                           "\nВы ввели: " + value.trimmed() +
                                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                        }

                        numberValues++; // инкрементируем количество чисел внутри '[' ']'
                    }
                }

                // Для каждого элемента массива values
                for(const QString& value : values)
                {
                    QString valInt = value.trimmed(); // удаляем начальные пробелы из подстроки

                    // Если длина числа больше 2 или в ней присутствует 0
                    if(valInt.count() > 2 || valInt[0] == '0')
                    {
                        // вызываем исключение о том, что числа могут лежать в диапазоне от 1 до 99 и 0 перед число писать нельзя и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                       "\nЦелочисленные значения должны лежать в диапазоне [1;99] (0 перед числом писать нельзя)."
                                       "\nВы ввели: " + valInt +
                                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }
                }

                // Если количество целочисленных значений между '[' ']' больше 9
                if(numberValues > 9)
                {
                    // вызываем исключение о том, что чисел между '[' ']' может быть от 1 до 9 и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nКоличество целочисленных значений между символами '[' и ']' должно быть от 1 до 9."
                                   "\nВы ввели " + QString::number(numberValues) +
                                   " значений.\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
                //----------------------------------------------------------------------------------------------------------------------
            }

            // Иначе если правило соответствует формату 3 паттерна
            else if (regex2.match(strOneRule[i]).hasMatch())
            {
                // Если последний символ не двойные кавычки и это не последнее правило
                if(strOneRule[i].lastIndexOf("\"") + 1 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                {
                    // вызываем исключение о том, что правило должно заканчиваться на " и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nПравило должно заканчиваться на ' \" '."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если последний символ не двойные кавычки и это последнее правило
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("\"") + 1] != ".")
                {
                    // вызываем исключение о том, что после " должна стоять точка и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nВ последнем правиле сразу после последней двойной кавычки \" должна стоять точка '.'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Для каждого символа подстроки дополнительного ограничения
                for(int j = 0; j < substrings[2].count(); j++)
                {
                    // Если между последними 2-мя двойными кавычками стоит что-либо кроме числа
                    if(!substrings[2][j].isNumber())
                    {
                        // вызываем исключение о том, что между последними двумя символами " должно быть положительное число и при том только 1 и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                       "\nМежду последними двумя символами ' \" ' должно быть только положительное целочисленное значение и только одно."
                                       "\nВы ввели: \"" + substrings[2] + "\""
                                                                          "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }
                }

                // Если число в дополнительном ограничении не лежит в диапазоне от 1 до 99
                if(substrings[2].toInt() < 1 || substrings[2].toInt() > 99)
                {
                    // вызываем исключение о том, что число должно лежать в диапазоне от 1 до 99 и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nЦелочисленное значение должно лежать в диапазоне [1;99]."
                                   "\nВы ввели: " + substrings[2] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Дополнительная проверна на слишком большое значение внутри двойных кавычек (больше int), а так же присудствие символа 0
                if(substrings[2].count() > 2 || substrings[2][0] == '0')
                {
                    // вызываем исключение о том, чтоо числа должны лежать в диапазоне от 1 до 99 и 0 перед числом писать нельзя и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nЦелочисленное значение должно лежать в диапазоне [1;99] (0 перед числом писать нельзя)."
                                   "\nВы ввели: " + substrings[2] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }
            }

            // Иначе если правило соответствует формату 2 паттерна
            else if (regex3.match(strOneRule[i]).hasMatch())
            {
                // Если количество двойных кавычек не равно 4
                if(strOneRule[i].count("\"") != 4)
                {
                    // вызываем исключение о том, что количество " должно быть равно 4 и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nКоличество символов ' \" ' должно быть равно четырём."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если правило не заканчивается на символы 'и' или 'м' и это не последнее правило
                if(strOneRule[i].lastIndexOf("и") + 1 != strOneRule[i].count() && strOneRule[i].lastIndexOf("м") + 1 != strOneRule[i].count()
                        && strOneRule[i].count(".") == 0)
                {
                    // вызываем исключение о том, что правило должно заканчиваться на м или и и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПравило должно заканчиваться на 'м' или 'и', в зависимости от указанного значения (одним) или (двумя - девятью)."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если правило не заканчивается на символы 'и' или 'м' и это последнее правило
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("и") + 1] != "."
                        && strOneRule[i][strOneRule[i].lastIndexOf("м") + 1] != ".")
                {
                    // вызываем исключение о том, что правило должно заканчиваться на м. или и. и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПравило должно заканичиваться на 'м.' или 'и.', в зависимости от указанного значения (одним) или (двумя - девятью)."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если в правиле нет слов 'значением' или 'значениями'
                if (!strOneRule[i].contains("значением") && !strOneRule[i].contains("значениями"))
                {
                    // вызываем исключение о том, что нет слова значением или значениями и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nОтсутствует слово 'значением' или 'значениями', в зависимости от указанного значения (одним) или (двумя - девятью)."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                QStringList values; // массив хранения допустимых значений в правиле с количеством целочисленных значений
                values << "одним" << "двумя" << "тремя" << "четырьмя" << "пятью" << "шестью" << "семью" << "восемью" << "девятью";
                bool ok = false; // флаг проверки наличия одного из значений массива допустимых значений

                // Для каждого элемента массива values
                for(const QString& value : values)
                {
                    // Если в строке найдено значение из массива
                    if(strOneRule[i].contains(value))
                    {
                        // поставить флаг в true
                        ok = true;
                    }
                }

                // Если нет ни одного значения из массива допустимых значений values в дополнительном ограничении
                if(!ok)
                {
                    // вызываем исключение о том, что могут быть только значения (одним - девятью) и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nНеверно введено количество целочисленных значений (недопустимое значение)."
                                   "\nДопустимы следующие значения: " + values[0] + ", " + values[1] + ", " + values[2] + ", " + values[3] + ", " + values[4] + ", "
                            + values[5] + ", " + values[6] + ", " + values[7] + ", " + values[8] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если записано 'одним' и после него не стоит 'значением'
                if(strOneRule[i].contains("одним") && !strOneRule[i].contains("значением"))
                {
                    // вызываем исключение о том, что правило должно заканчиваться словом значением и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nЕсли было введено 'одним', то правило должно заканчиваться на 'значением'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если написано 'двумя' - 'девятью' и после него не стоит 'значениями'
                if(!strOneRule[i].contains("одним") && !strOneRule[i].contains("значениями"))
                {
                    // вызываем исключение о том, что правило должно заканчиваться на значениями и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nЕсли было введено ('двумя' - 'девятью'), то правило должно заканчиваться на 'значениями'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если слово 'значением' или 'значениями' встречается больше одного раза
                if(strOneRule[i].count("значением") > 1 || strOneRule[i].count("значениями") > 1)
                {
                    // вызываем исключение о том, что можно писать только одно слово значением или значение и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПравило должно содержать одно слово: ('значением' или 'значениями')."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если в одном правиле есть слова 'значением' и 'значениями'
                if((strOneRule[i].count("значением") == 1 && strOneRule[i].count("значениями") != 0)
                        || (strOneRule[i].count("значением") != 0 && strOneRule[i].count("значениями") == 1))
                {
                    // вызываем исключение о том, что что можно писать только одно слово значением или значение и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПравило должно содержать одно слово 'значением' или 'значениями'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                QStringList strLastValue = strOneRule[i].split(" "); // разбиваем строку на подстроки по пробелу

                // Если правило не заканчивается на 'значением' и не заканчивается на 'значениями'
                if(strLastValue[strLastValue.count() - 1] != "значением" && strLastValue[strLastValue.count() - 1] != "значениями"
                        && strLastValue[strLastValue.count() - 1] != "значением." && strLastValue[strLastValue.count() - 1] != "значениями.")
                {
                    // вызываем исключенеи о том, что можно писать только одно слово значение или значением (не вместе) и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПравило должно заканчиваться на слово 'значением' или 'значениями'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

            }

            /* Если ни 4, ни 3, ни 2 паттерн не подошли под строку (если сюда попали правила похожие на паттерны 2, 3 или 4,
              то проводим дополнительную проверку на ошибки)*/
            else
            {
                // Если строка содердит по одному символу '[' ']' и при этом они стоят рядом (ошибка правила с массивом целочисленных значений)
                if(strOneRule[i].count("[") == 1 && strOneRule[i].count("]") == 1 &&
                        (strOneRule[i].indexOf("]") - strOneRule[i].indexOf("[")) == 1)
                {
                    // вызываем исключение о том, что между '[' ']' должно быть от 1 до 9 чисел и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "(между символами '[' ']' должно быть от 1 до 9 целочисленных значений)."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                /* Если строка напоминает правило с количеством целочисленных значений и после текстового ограничения неверно стоит запятая
                 (частая ошибка, есть смысл выделить в отдельную проверку)*/
                if(strOneRule[i].contains("которое представлено") && (!strOneRule[i][strOneRule[i].lastIndexOf(",") + 1].isSpace()
                                                                      || strOneRule[i][strOneRule[i].lastIndexOf(",") - 1] != "\""))
                {
                    // вызываем ограничение о том, что после текстового ограничения должна идти запятая и пробел и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nПосле текстового ограничения должна стоять запятая и пробел \', \'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если строка напоминает правило с количеством целочисленных значений
                if(strOneRule[i].contains("которое представлено") && strOneRule[i].contains("значени"))
                {
                    QStringList values; // массив хранения допустимых значений в правиле с количеством целочисленных значений
                    values << "одним" << "двумя" << "тремя" << "четырьмя" << "пятью" << "шестью" << "семью" << "восемью" << "девятью";
                    bool ok = false; // флаг проверки наличия одного из значений массива допустимых значений
                    int valueCount = 0; // количество переменных из списка допустимых значений в тексте одного правила

                    // Для каждого элемента массива values
                    for(const QString& value : values)
                    {
                        // Если в строке найдено значение из массива
                        if(strOneRule[i].contains(value))
                        {
                            ok = true; // флаг перевести в true
                            valueCount++; // инкрементрировать количество переменных в тексте одного правила
                        }
                    }

                    // Если нет ни одного значения из массива допустимых значений values в дополнительном ограничении
                    if(!ok)
                    {
                        // вызываем исключение о том, что могут быть только значения (одним - девятью) и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                       "\nНеверно введено количество целочисленных значений (недопустимое значение)."
                                       "\nДопустимы следующие значения: " + values[0] + ", " + values[1] + ", " + values[2] + ", " + values[3] + ", " + values[4] + ", "
                                + values[5] + ", " + values[6] + ", " + values[7] + ", " + values[8] +
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }

                    // Если количество переменных из массива допустимых значений в строке больше одного
                    if(valueCount > 1)
                    {
                        // вызываем исключение о том, что могут быть только значения (одним - девятью) и выводим ошибочное правило
                        throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                       "\nОграничение по количеству целочисленных значений записи должно быть представлено единственным значением."
                                       "\nДопустимы следующие значения: " + values[0] + ", " + values[1] + ", " + values[2] + ", " + values[3] + ", " + values[4] + ", "
                                + values[5] + ", " + values[6] + ", " + values[7] + ", " + values[8] +
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                    }
                }

                /* Если строка напоминает правило с одним целочисленным значением и после текстового ограничения неверно стоит запятая
                (частая ошибка, есть смысл выделить в отдельную проверку)*/
                if(strOneRule[i].contains("в составе которого есть значение") && (!strOneRule[i][strOneRule[i].lastIndexOf(",") + 1].isSpace()
                                                                                  || strOneRule[i][strOneRule[i].lastIndexOf(",") - 1] != "\""))
                {
                    // вызываем исключение о том, что после текстового ограничения должна стоять запятая и пробел и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nПосле текстового ограничения должна стоять запятая и пробел \', \'."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                // Если строка напоминает правило с одним целочисленным значением и между последними двойными кавычками нет ничего
                if(strOneRule[i].contains("в составе которого есть значение") && strOneRule[i][strOneRule[i].lastIndexOf("\"") - 1] == "\"")
                {
                    // вызываем исключение о том, что поле доплнительного ограничения не может быть пустым и выводим ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nПоле дополнительного ограничения не должно быть пустым. Внутри двойных кавычек должно быть одно число от 1 до 99."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]);
                }

                QString delSpaseStr = strOneRule[i]; // создаём строку теста правила
                delSpaseStr.remove(' '); // удаляем все пробелы

                // Если строка напоминает правило с массивом целочисленных значений
                if(delSpaseStr.contains("изначениеэтогосвойстваравно"))
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\nПравильный формат:"
                                   "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<текстовое ограничение>\" и значение этого свойства равно \"[<целочисленные значения через ','>]\"");
                }

                // Иначе если строка напоминает правило с количеством целочисленных значений
                else if(delSpaseStr.contains("котороепредставлено"))
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\n\nПравильный формат:"
                                   "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<текстовое ограничение>\", которое представлено <кол-во значений в виде текста> значением(ями)");
                }

                // Иначе если строка напоминает правило с одним целочисленным значением
                else if(delSpaseStr.contains("всоставекоторогоестьзначение"))
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\n\nПравильный формат:"
                                   "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"");
                }

                // Если строка содержит не 4 двойных кавычек
                if(strOneRule[i].count("\"") != 4)
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода правила."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\n\nДопустимые форматы: "
                                   "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                                   "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                                   "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                                   "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
                }

                // Если последняя строка не заканчивается двойной кавычкой
                if(strOneRule[i].lastIndexOf("\"") + 1 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода правила."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\n\nДопустимые форматы: "
                                   "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                                   "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                                   "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                                   "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
                }

                // Если последняя строка не заканчивается двойной кавычкой
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("\"") + 1] != ".")
                {
                    // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
                    throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода правила."
                                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                                   "\n\nДопустимые форматы: "
                                   "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                                   "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                                   "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                                   "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
                }
            }
            numberRuleName.append(substrings[0]); // добавляем название класса для последующей проверки на совпадения
        }

        // Если ни один из паттернов не подошёл, то выводим сообщение об ошибке
        else
        {
            // вызываем исключение о том, что формат неверен и выводим правильный формат и ошибочное правило
            throw QString ("Текст правил классификации:\nОшибка! Неверный формат ввода правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                           "\n\nДопустимые форматы: "
                           "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                           "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                           "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                           "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'");
        }
    }

    //-------------------------------Блок проверки на совпадения названий классов--------------------------------------------------
    // Для каджого названия класса
    for (int i = 0; i < numberRuleName.count(); i++)
    {
        const QString& currentString = numberRuleName[i]; // создаём неизменяемую строку в которую присваиваем текущее название класса (i)

        // Для каждого названия класса, идущего после текущего
        for (int j = i + 1; j < numberRuleName.count(); j++)
        {
            const QString& otherString = numberRuleName[j]; // создаём неизменяемую строку в которую присваиваем текущее название класса (j)

            // Если названия классов совпали
            if (currentString == otherString)
            {
                // вызываем исключение о том, что названия классов повторяются и выводим номера повторяющихся правил и названия класса
                throw QString ("Текст правил классификации:\nОшибка! Названия классов не могут повторяться."
                               "\nНазвание класса: \"" + currentString +
                               "\"\nПовторение в правилах: " + QString::number(i + 1) + " и " + QString::number(j + 1));
            }
        }
    }
    //-----------------------------------------------------------------------------------------------------------------------------

    //---------------------------------Блок проверки на совпадения ограничений правил классификации--------------------------------
    // Для каждого правила
    for(int i = 0; i < strOneRule.count(); i++)
    {
        // создаём строку и присваиваем ему подстроку следующую после названия класса (i)
        QString currentString = strOneRule[i].mid(strOneRule[i].indexOf("\"", 29) + 1);
        currentString.remove(" "); // удаляем из созданной строки все пробелы

        // Если есть точка в подстроке, удаляем её
        if(currentString.count(".") != 0)
        {
            // удалем точку
            currentString.remove(".");
        }

        // Для каждого правила следующего после текущего
        for(int j = i + 1; j < strOneRule.count(); j++)
        {
            // создаём строку и присваиваем ему подстроку следующую после названия класса (j)
            QString otherString = strOneRule[j].mid(strOneRule[j].indexOf("\"", 29) + 1);
            otherString.remove(" "); // удаляем из созданной строки все пробелы

            // Если есть точка в подстроке, удаляем её
            if(otherString.count(".") != 0)
            {
                // удаляем точку
                otherString.remove(".");
            }

            // Если ограничения правил совпали
            if (currentString == otherString)
            {
                // вызываем исключение о том, что условия классификации повтоярются и выводим условие классификации и номера правил
                throw QString ("Текст правил классификации:\nОшибка! Условия классификации не могут повторяться."
                               "\nУсловие классификации: \"" + strOneRule[i].mid(strOneRule[i].indexOf("\"", 29) + 3) +
                               "\"\nПовторение в правилах: " + QString::number(i + 1) + " и " + QString::number(j + 1));
            }
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------
}

ConditionType ClassificationRules::getCondition()
{
    // вернуть текущее значение типа правила
    return this -> condition;
}

LimitationIntegerValues ClassificationRules::getLimitValue()
{
    // вернуть текущее значение количества целочисленных значений заданных в оганичении
    return this -> limitValue;
}

QString ClassificationRules::getName()
{
    // вернуть текущее имя класса
    return this -> name;
}

QString ClassificationRules::getConstraint()
{
    // вернуть текущее название текстового ограничения
    return this -> constraint;
}

QList<int> ClassificationRules::getIntegerValues()
{
    // вернуть текущие значения дополнительного ограничения в виде целочисленных значений
    return this -> integerValues;
}
