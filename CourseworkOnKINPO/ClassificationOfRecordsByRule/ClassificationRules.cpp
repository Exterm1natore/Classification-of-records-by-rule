#include "ClassificationRules.h"

ClassificationRules::ClassificationRules()
{
    name = "";
    constraint = "";
}

QString ClassificationRules::splitStringOfClassificationRules(const QString& rulesData, QList<ClassificationRules>* classificationRules)
{
    ClassificationRules checkRules; // создаём переменную класса ClassificationRules
    // создаём строку и присваиваем ей значение, которое вернёт функция проверки текста правил классификации
    QString errRule = checkRules.checkClassificationRules(rulesData);

    // Если функция проверки не вернула строку "Всё хорошо!"
    if(!errRule.contains("Всё хорошо!")) // завершаем выполнение функции и возвращаем текст ошибки
        return errRule;

    // Иначе
    else
    {
        QStringList substringsRules = rulesData.split(";"); // делим текст правил классификации по символу точка с запятой (';')

        // Для каждой строки поделённого текста
        for(int i = 0; i < substringsRules.count(); i++)
        {
            ClassificationRules newRule; // создаём переменную класса ClassificationRules
            QRegExp classRx("\"([^\"]+)\""); // регулярное выражение для поиска слов внутри двойных кавычек (' " ')
            QRegExp propertyRx("свойство \"([^\"]+)\""); // регулярное выражение для слов после слова "свойство \"" и до закрывающей двойной кавычки
            int classPos = classRx.indexIn(substringsRules[i]); // получаем индекс первых двух двойных кавычек

            // Если регулярное выражение нашло слово то записываем название класса
            if (classPos != -1)
                newRule.name = classRx.cap(1);

            int propertyPos = propertyRx.indexIn(substringsRules[i]); // получаем индекс следующих двух двойных кавычек

            // Если регулярное выражение нашло слово то записываем название текстового ограничения
            if (propertyPos != -1)
                newRule.constraint = propertyRx.cap(1);

            // создаём строку соответствующую правилу с дополнительным ограничением в виде количества целочисленных значений
            QString withLength = "которое представлено";
            // создаём строку соответствующую правилу с дополнительным ограничением в виде одного целочисленного значения
            QString singleValue = "в составе которого есть значение";
            // создаём строку соответствующую правилу с дополнительным ограничением в виде массива целочисленных значений
            QString severalValues = "и значение этого свойства равно";

            // Если строка соответствует правилу с дополнительным ограничением в виде количества целочисленных значений
            if(substringsRules[i].contains(withLength))
            {
                newRule.condition = propertyWithLength; // устанавливаем тип правила с количеством целочисленных значений

                // Если есть слово "одним", записываем в emun соответствующее значение
                if(substringsRules[i].contains("одним"))
                    newRule.limitValue = Single;

                // Если есть слово "двумя", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("двумя"))
                    newRule.limitValue = Two;

                // Если есть слово "тремя", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("тремя"))
                    newRule.limitValue = Three;

                // Если есть слово "четырьмя", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("четырьмя"))
                    newRule.limitValue = Four;

                // Если есть слово "пятью", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("пятью"))
                    newRule.limitValue = Five;

                // Если есть слово "шестью", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("шестью"))
                    newRule.limitValue = Six;

                // Если есть слово "семью", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("семью"))
                    newRule.limitValue = Seven;

                // Если есть слово "восемью", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("восемью"))
                    newRule.limitValue = Eight;

                // Если есть слово "девятью", записываем в emun соответствующее значение
                else if(substringsRules[i].contains("девятью"))
                    newRule.limitValue = Nine;
            }

            // Иначе если строка соответствует правилу с дополнительным ограничением в виде одного целочисленного значения
            else if(substringsRules[i].contains(singleValue))
            {
                newRule.condition = propertySingleValue; // устанавливаем тип правила с одним целочисленным значением
                newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста
                QRegExp rxValue("(\\d+)"); // создаём регулярное выражение, которое ищет последовательность одной или более цифр в тексте
                int pos = 0; // создаём переменную равную позиции цифр в тексте

                // Пока есть числа в тексте
                while ((pos = rxValue.indexIn(substringsRules[i], pos)) != -1)
                {
                    newRule.integerValues.append(rxValue.cap(1).toInt()); // записываем число в контейнер целочисленных значений
                    pos += rxValue.matchedLength(); // ищем следующие цифры в строке
                }
            }

            // Иначе если строка соответствует правилу с дополнительным ограничением в виде массива целочисленных значений
            else if(substringsRules[i].contains(severalValues))
            {
                newRule.condition = propertyWithSeveralValues; // устанавливаем тип правила с массивом целочисленных значений
                newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста

                int start = substringsRules[i].indexOf('['); // ищем первый символ '['
                int end = substringsRules[i].indexOf(']'); // ищем первый символ ']'
                QString substring = substringsRules[i].mid(start + 1, end - start - 1); // вырезаем подстроку между скобками
                QStringList values = substring.split(",", QString::SkipEmptyParts); // разделяем подстроку по запятой

                // Для каждого числа в строке
                for (const QString& value : values)
                {
                    bool ok; // флаг, указывающий на удачноть преобразования подстроки в int
                    int intValue = value.trimmed().toInt(&ok); // преобразуем строку в целое число

                    // Если подстрока успешно преобразована
                    if (ok)
                        newRule.integerValues.append(intValue); // записываем число в контейнер целочисленных значений
                }
            }

            // Иначе
            else
            {
                newRule.condition = propertyWithNoValue; // устанавливаем тип правила без дополнительного ограничения
                newRule.limitValue = NotQuantity; // устанавливаем значение, что число представлено не в виде текста
            }

            classificationRules->append(newRule); // записываем полученные значения текущей строки в контейнер класса ClassificationRules
        }

        // Возвращаем текст полученный из функции 'checkClassificationRules'
        return errRule;
    }
}

QString ClassificationRules::checkClassificationRules(const QString& strRule)
{
    // Паттерн для проверки первого типа строки
    QString pattern1 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\"";

    // Паттерн для проверки второго типа строки
    QString pattern2 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]+) значени";

    // Паттерн для проверки третьего типа строки
    QString pattern3 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\", в составе которого есть значение \"(.+)\"";

    // Паттерн для проверки четвёртого типа строки
    QString pattern4 = "Запись принадлежит классу \"(.+)\", если у нее есть свойство \"(.+)\" и значение этого свойства равно \"\\[(.+)\\]\"";

    // Регулярное выражение четвёрного паттерна
    QRegularExpression regex1(pattern4);

    // Регулярное выражение третьего паттерна
    QRegularExpression regex2(pattern3);

    // Регулярное выражение второго паттерна
    QRegularExpression regex3(pattern2);

    // Регулярное выражение первого паттерна
    QRegularExpression regex4(pattern1);

    // Если входной текст правил классификации является пустым
    QString emptyStr = strRule.trimmed();
    if(emptyStr.isEmpty())
        return "Ошибка! Файл с входными данными правил классификации является пустым.";

    // Если входной текст правил классификации не заканчивается точкой - вернуть ошибку
    if (!strRule.endsWith("."))
        return "Ошибка! В конце текста правил классификации должна стоять точка ('.')."; //Если заканчивается не на точку

    // Если в тексте правил классификации больше одной точки - вернуть ошибку
    if (strRule.count(".") > 1)
        return "Ошибка! В тексте правил классификации может быть только одна точка ('.'), которая должна находится после последнего правила."
               "\nНомер ошибочного символа в тексте с правилами классификации: " + QString::number(strRule.indexOf(".") + 1);

    // Разделить текст правил по символу разделения правил классификации - точки с запятой
    const QStringList& strOneRule = strRule.split(";", QString::SkipEmptyParts);

    // Вернуть ошибку, если количество правил классификации превышает 100
    if(strOneRule.count() > 100)
        return "Ошибка! Количество записей не должно превышать 100. Допустимый диапазон: [1;100].";

    // Контейнер для хранения названий классов, для последующего сравнения и поиска совпадений
    QList<QString> numberRuleName;

    // Для каждого правила (правила разделены символом ';')
    for(int i = 0; i < strOneRule.count(); i++)
    {
        /* Если слово 'нее' в правиле было написано сечерез 'ё' (проверка имеет смысл, т.к. ошибка частая и чтобы конкретезиовать её тип
         есть смысл выделить в отдельную проверку)*/
        if(strOneRule[i].contains("если у неё есть свойство"))
            return "Ошибка! Слово \'неё\' можно писать только через \'е\'."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

        // Если правило не заканчивается на ' " ', '.', 'и' или 'м' (то есть правило имееет неверный формат)
        if(strOneRule[i][strOneRule[i].count() - 1] != "\"" && strOneRule[i][strOneRule[i].count() - 1] != "."
                && strOneRule[i][strOneRule[i].count() - 1] != "и" && strOneRule[i][strOneRule[i].count() - 1] != "м")
            return "Ошибка! Неверный формат ввода. Правило должно заканчиваться на следующие символы ('\" или '.' или 'и' или 'м')"
                   ", в зависимости от типа правила."
                   "\nПроверьте правильность постановки точки с запятой \';\'."
                   "\nОшибка в тексте правила " + QString::number(i + 1) + ": " + strOneRule[i] +
                    ";\n\nДопустимые форматы: "
                    "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                    "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                    "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                    "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'";

        /* Если правило начинается не с указанного формата, а с пробела (то же довольно частая ошибка,
          есть смысл выделить в отдельную проверку)*/
        if(strOneRule[i][0].isSpace())
            return "Ошибка! Правило не может начинаться с пробела."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

        // Проверка на что во всем тексте текущего правила не стоит больше одного пробела (для каждого символа строки)
        for(int j = 0; j < strOneRule[i].count() - 1; j++)
            if(strOneRule[i][j].isSpace() && strOneRule[i][j + 1].isSpace())
            {
                QString errTXT = strOneRule[i]; // создаём строку и присваиваем значение текущей строки правил
                errTXT.replace(" ", "*", Qt::CaseInsensitive); //меняем для наглядности все пробелы звёздочками (*)
                return "Ошибка! В тексте правила не допускается использовать больше одного пробела подряд."
                       "\nОшибка в правиле " + QString::number(i + 1) + ": " + errTXT;
            }

        // Проверка что правила классификации не разделены символом точкой с запятой (частая ошибка, выделяем в отдельную проверку)
        if(strOneRule[i].count("\"") != 4 && strOneRule[i].count("\"") != 6 && strOneRule[i].count("Запись принадлежит классу") > 1)
            return "Ошибка! Правила классификации должны быть разделены точкой с запятой \';\'."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

        // Проверка что в правиле стоит 4 или 6 двойных кавычек ' " ' (общая проверка на лишние символы)
        else if (strOneRule[i].count("\"") != 4 && strOneRule[i].count("\"") != 6)
            return "Ошибка! В правиле должно быть либо 4, либо 6 двойных кавычек ('\"') в зависимости от типа правила."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

        // Проверка что текст правила начинается с указанного формата и перед ним не стоят другие символы
        if(!strOneRule[i].startsWith("Запись принадлежит классу") || strOneRule[i].count("Запись принадлежит классу") != 1)
            return "Ошибка! Неверный формат ввода правила."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                    "\n\nДопустимые форматы: "
                    "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                    "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                    "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                    "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'";

        // Если правило подходит хотя бы под один из указанных паттернов
        if(regex1.match(strOneRule[i]).hasMatch() || regex2.match(strOneRule[i]).hasMatch()
                || regex3.match(strOneRule[i]).hasMatch() || regex4.match(strOneRule[i]).hasMatch())
        {
            // Хранение текста между двойными кавычками текущего правила
            QStringList substrings;

            // Получение текста между двойными кавычками в текущем правиле
            int startPos = strOneRule[i].indexOf("\"");
            // Пока есть двойные кавычки
            while (startPos != -1)
            {
                // Получение индекса следующей двойной кавычки после текущей двойной кавычки
                int endPos = strOneRule[i].indexOf("\"", startPos + 1);

                // Если не последняя двойная кавычка
                if (endPos != -1)
                {
                    // Получение подстроки внутри двойных кавычек и передох к следующей паре двойных кавычек
                    QString substring = strOneRule[i].mid(startPos + 1, endPos - startPos - 1);
                    substrings.append(substring);
                    startPos = strOneRule[i].indexOf("\"", endPos + 1);
                }
                else
                    break;
            }

            // Провека, что текст в двойных кавычках текущего правила не начинается и не заканчивается буквой
            for(int j = 0; j < 2; j++)
                if(!substrings[j][0].isLetter() || !substrings[j][substrings[j].count() - 1].isLetter())
                    return "Ошибка! Внутри двойных кавычек ('\"') текст не может начинаться и заканчиваться не буквой."
                           "\nВы ввели: " + substrings[j] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Провека, что название класса содержит от 3 до 20 символов
            if(substrings[0].count() < 3 || substrings[0].count() > 20)
                return "Ошибка! Название класса не может быть меньше трёх или больше двадцати символов."
                       "\nВы ввели: " + substrings[0] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Проверка что текстовое ограничение правила содержит от 3 до 20 символов
            if(substrings[1].count() < 3 || substrings[1].count() > 20)
                return "Ошибка! Текстовое ограничение правила не может быть меньше трёх или больше двадцати символов."
                       "\nВы ввели: " + substrings[1] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Проверка что название класса начинается с заглавной буквы
            if(!substrings[0][0].isUpper())
                return "Ошибка! Название класса должно начинаться с заглавной буквы."
                       "\nВы ввели " + substrings[0] +
                        "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Проверка, что в названии класса все буквы, кроме первой в нижнем регистре
            for(int j = 1; j < substrings[0].count(); j++)
                if(!substrings[0][j].isSpace() && substrings[0][j].isUpper())
                    return "Ошибка! В названии класса все буквы, кроме первой, должны быть в нижнем регистре."
                           "\nВы ввели: " + substrings[0] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Проверка, что в названии класса используются только буквы русского или английского алфавита и нет иных символов
            for(int j = 0; j < substrings[0].count(); j++)
                if(!substrings[0][j].isLetter() && !substrings[0][j].isSpace())
                    return "Ошибка! В названии класса допускается использование только букв русского или английского алфавита "
                           "и пробелов (не больше одного подряд)."
                           "\nВы ввели: " + substrings[0] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Провека, что в текстовом ограничении используются только буквы русского или английского алфавите и нет иных символов
            for(int j = 0; j < substrings[1].count(); j++)
                if(!substrings[1][j].isLetter())
                    return "Ошибка! Текстовое ограничение может содержать только буквы русского или английского алфавита и не должно содержать пробелы."
                           "\nВы ввели: " + substrings[1] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Проверка, что текстовое ограничение содержит только буквы в нижнем регистре
            for(int j = 0; j < substrings[1].count(); j++)
                if(!substrings[1].isLower())
                    return "Ошибка! Текстовое ограничение может содержать только буквы в нижнем регистре."
                           "\nВы ввели: " + substrings[1] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

            // Если правило соответсвует формату 4 паттерна
            if (regex1.match(strOneRule[i]).hasMatch())
            {
                // Если в правиле соответствующего 4 паттерну не по одной квадратной скобке
                if(strOneRule[i].count("[") != 1 && strOneRule[i].count("]") != 1)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nДанный тип правила должен содержать по одному символу '[' и ']'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если после правила есть лишние символы
                if(strOneRule[i].indexOf("]") + 2 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nДанный тип правила должен заканчиваться на ']\"'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если после правила есть лишние символы
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].indexOf("]") + 2] != ".")
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nДанный тип правила должен заканчиваться на ']\".'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                //---------------------------Болок проверки символов внутри квадратных скобок------------------------------------
                int checkStart = strOneRule[i].indexOf('['); // ищем первый символ '['
                int checkEnd = strOneRule[i].indexOf(']'); // ищем первый символ ']'

                // Если между квадратными скобками нет ничего
                if(checkEnd - checkStart == 1)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nПоле между символами '[' и ']' не должно быть пустым."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если после символа '[' стоит не цифра
                if(!strOneRule[i][checkStart+ 1].isNumber())
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nНе допускается сразу после символа '[' использование чего-либо, кроме цифр."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если перед символом ']' стоит не цифра
                if(!strOneRule[i][checkEnd - 1].isNumber())
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nНе допускается сразу перед символом ']' использование чего-либо, кроме цифр."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                int position; // текущая позиция в строке
                position = checkStart + 1; // позиция должна начинаться со следующего символа после '['

                // Пока не позиция в строке не равна ']'
                while(strOneRule[i][position] != "]")
                {
                    // Если между '[' ']' используется что-либо кроме цифр, пробела или запятой
                    if(!strOneRule[i][position].isNumber() && !strOneRule[i][position].isSpace() && strOneRule[i][position] != ",")
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                               "\nНе допускается использование между символами '[' и ']' всего, кроме 'пробела', ',' или цифр."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    // Если между символами '[' ']' стоит больше одного пробела подряд
                    if(strOneRule[i][position].isSpace() && strOneRule[i][position + 1].isSpace())
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                               "\nНе допускается между символами '[' и ']' использование больше одного 'пробела' подряд."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    // Если между символами '[' ']' стоит больше одной запятой подряд
                    if(strOneRule[i][position] == "," && strOneRule[i][position + 1] == ",")
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                               "\nНе допускается между символами '[' и ']' использование больше одной запятой (',') подряд."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    // Если между символами '[' ']' стоит пробел и после него запятая
                    if(strOneRule[i][position].isSpace() && strOneRule[i][position + 1] == ",")
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                               "\nНе допускается между символами '[' и ']' использование после 'пробела' запятой (',')."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    // Если следующий символ не ']' и после числа не стоит запятая
                    if(strOneRule[i][position + 1] != "]" && strOneRule[i][position].isNumber()
                            && !strOneRule[i][position + 1].isNumber() && strOneRule[i][position + 1] != ",")
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                               "\nМежду символами '[' и ']' после числа должна стоять запятая (',')."
                               "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    position ++; // Перейти к следующему символу
                }

                int start = strOneRule[i].indexOf('['); // ищем первый символ '['
                int end = strOneRule[i].indexOf(']'); // ищем первый символ ']'

                QString substring = strOneRule[i].mid(start + 1, end - start - 1); // вырезаем подстроку между скобками
                QStringList values = substring.split(",", QString::SkipEmptyParts); // разделяем подстроку по запятой
                int numberValues = 0; // количество чисел внутри '[' ']'

                // Для каждого числа между '[' ']'
                for (const QString& value : values)
                {
                    bool ok; // флаг преобразования подстроки в int
                    int intValue = value.trimmed().toInt(&ok); // преобразуем строку в целое число

                    // Если удалось преобразовать подстроку в целое число
                    if (ok)
                    {
                        // Если число не лежит в диапазоне от 1 до 99
                        if(intValue < 1 || intValue > 99)
                            return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                                   "\nМежду символами '[' и ']' числа должны лежать в диапазоне [1;99]."
                                   "\nВы ввели: " + value.trimmed() +
                                    "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                        numberValues++; // инкрементируем количество чисел внутри '[' ']'
                    }
                }

                // Для каждого элемента массива values
                for(const QString& value : values)
                {
                    QString valInt = value.trimmed(); // удаляем начальные пробелы из подстроки

                    // Если длина числа больше 2 или в ней присутствует 0
                    if(valInt.count() > 2 || valInt[0] == '0')
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                               "\nЦелочисленные значения должны лежать в диапазоне [1;99] (0 перед числом писать нельзя)."
                               "\nВы ввели: " + valInt +
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];
                }

                // Если количество целочисленных значений между '[' ']' больше 9
                if(numberValues > 9)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nКоличество целочисленных значений между символами '[' и ']' должно быть от 1 до 9."
                           "\nВы ввели " + QString::number(numberValues) +
                            " значений.\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];;
                //----------------------------------------------------------------------------------------------------------------------
            }

            // Иначе если правило соответствует формату 3 паттерна
            else if (regex2.match(strOneRule[i]).hasMatch())
            {
                // Если последний символ не двойные кавычки и это не последнее правило
                if(strOneRule[i].lastIndexOf("\"") + 1 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nПравило должно заканчиваться на ' \" '."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если последний символ не двойные кавычки и это последнее правило
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("\"") + 1] != ".")
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nВ последнем правиле сразу после последней двойной кавычки \" должна стоять точка '.'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Для каждого символа подстроки дополнительного ограничения
                for(int j = 0; j < substrings[2].count(); j++)

                    // Если между последними 2-мя двойными кавычками стоит что-либо кроме числа
                    if(!substrings[2][j].isNumber())
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                               "\nМежду последними двумя символами ' \" ' должно быть только положительное целочисленное значение и только одно."
                               "\nВы ввели: \"" + substrings[2] + "\""
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если число в дополнительном ограничении не лежит в диапазоне от 1 до 99
                if(substrings[2].toInt() < 1 || substrings[2].toInt() > 99)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nЦелочисленное значение должно лежать в диапазоне [1;99]."
                           "\nВы ввели: " + substrings[2] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Дополнительная проверна на слишком большое значение внутри двойных кавычек (больше int), а так же присудствие символа 0
                if(substrings[2].count() > 2 || substrings[2][0] == '0')
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nЦелочисленное значение должно лежать в диапазоне [1;99] (0 перед числом писать нельзя)."
                           "\nВы ввели: " + substrings[2] +
                            "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];
            }

            // Иначе если правило соответствует формату 2 паттерна
            else if (regex3.match(strOneRule[i]).hasMatch())
            {
                // Если количество двойных кавычек не равно 4
                if(strOneRule[i].count("\"") != 4)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nКоличество символов ' \" ' должно быть равно четырём."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если правило не заканчивается на символы 'и' или 'м' и это не последнее правило
                if(strOneRule[i].lastIndexOf("и") + 1 != strOneRule[i].count() && strOneRule[i].lastIndexOf("м") + 1 != strOneRule[i].count()
                        && strOneRule[i].count(".") == 0)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПравило должно заканичиваться на 'м' или 'и', в зависимости от указанного значения (одним) или (двумя - девятью)."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если правило не заканчивается на символы 'и' или 'м' и это последнее правило
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("и") + 1] != "."
                        && strOneRule[i][strOneRule[i].lastIndexOf("м") + 1] != ".")
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПравило должно заканичиваться на 'м.' или 'и.', в зависимости от указанного значения (одним) или (двумя - девятью)."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если в правиле нет слов 'значением' или 'значениями'
                if (!strOneRule[i].contains("значением") && !strOneRule[i].contains("значениями"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nОтсутствует слово 'значением' или 'значениями', в зависимости от указанного значения (одним) или (двумя - девятью)."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если записано 'одним' и после него не стоит 'значением'
                if(strOneRule[i].contains("одним") && !strOneRule[i].contains("значением"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nЕсли было введено 'одним', то правило должно заканчиваться на 'значением'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]; //одним должно быть в единственном числе

                // Если написано 'двумя' - 'девятью' и после него не стоит 'значениями'
                if(!strOneRule[i].contains("одним") && !strOneRule[i].contains("значениями"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nЕсли было введено ('двумя' - 'девятью'), то правило должно заканчиваться на 'значениями'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]; //Должно быть во множественном числе

                // Если слово 'значением' или 'значениями' встречается больше одного раза
                if(strOneRule[i].count("значением") > 1 || strOneRule[i].count("значениями") > 1)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПравило должно содержать одно слово 'значением' или 'значениями'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]; //НЕ может быть больше одного

                // Если в одном правиле есть слова 'значением' и 'значениями'
                if((strOneRule[i].count("значением") == 1 && strOneRule[i].count("значениями") != 0)
                        || (strOneRule[i].count("значением") != 0 && strOneRule[i].count("значениями") == 1))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПравило должно содержать одно слово 'значением' или 'значениями'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]; //НЕ может быть больше одного

                QStringList strLastValue = strOneRule[i].split(" "); // разбиваем строку на подстроки по пробелу

                // Если правило не заканчивается на 'значением' и не заканчивается на 'значениями'
                if(strLastValue[strLastValue.count() - 1] != "значением" && strLastValue[strLastValue.count() - 1] != "значениями"
                        && strLastValue[strLastValue.count() - 1] != "значением." && strLastValue[strLastValue.count() - 1] != "значениями.")
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПравило должно заканчиваться на слово 'значением' или 'значениями'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i]; //НЕ заканчивается на значением

            }

            /* Если ни 4, ни 3, ни 2 паттерн не подошли под строку (если сюда попали правила похожие на паттерны 2, 3 или 4,
              то проводим дополнительную проверку на ошибки)*/
            else
            {
                // Если строка содердит по одному символу '[' ']' и при этом они стоят рядом (ошибка правила с массивом целочисленных значений)
                if(strOneRule[i].count("[") == 1 && strOneRule[i].count("]") == 1 &&
                        (strOneRule[i].indexOf("]") - strOneRule[i].indexOf("[")) == 1)
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "(между символами '[' ']' должно быть от 1 до 9 целочисленных значений)."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                /* Если строка напоминает правило с количеством целочисленных значений и после текстового ограничения неверно стоит запятая
                 (частая ошибка, есть смысл выделить в отдельную проверку)*/
                if(strOneRule[i].contains("которое представлено") && (!strOneRule[i][strOneRule[i].lastIndexOf(",") + 1].isSpace()
                                                                      || strOneRule[i][strOneRule[i].lastIndexOf(",") - 1] != "\""))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nПосле текстового ограничения должна стоять запятая и пробел \', \'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если строка напоминает правило с количеством целочисленных значений
                if(strOneRule[i].contains("которое представлено") && strOneRule[i].contains("значени"))
                {
                    QStringList values; // массив хранения допустимых значений в правиле с количеством целочисленных значений
                    values << "одним" << "двумя" << "тремя" << "четырьмя" << "пятью" << "шестью" << "семью" << "восемью" << "девятью";
                    bool ok = false; // флаг проверки наличия одного из значений массива допустимых значений
                    int valueCount = 0; // количество переменных из списка допустимых значений в тексте одного правила

                    // Для каждого элемента массива values
                    for(const QString& value : values)
                        // Если в строке найдено значение из массива
                        if(strOneRule[i].contains(value))
                        {
                            ok = true; // флаг перевести в true
                            valueCount++; // инкрементрировать количество переменных в тексте одного правила
                        }

                    // Если нет ни одного значения из массива допустимых значений values в дополнительном ограничении
                    if(!ok)
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                               "\nНеверно введено количество целочисленных значений (недопустимое значение)."
                               "\nДопустимы следующие значения: " + values[0] + ", " + values[1] + ", " + values[2] + ", " + values[3] + ", " + values[4] + ", "
                                + values[5] + ", " + values[6] + ", " + values[7] + ", " + values[8] +
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                    // Если количество переменных из массива допустимых значений в строке больше одного
                    if(valueCount > 1)
                        return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                               "\nОграничение по количеству целочисленных значений записи должно быть представлено единственным значением."
                               "\nДопустимы следующие значения: " + values[0] + ", " + values[1] + ", " + values[2] + ", " + values[3] + ", " + values[4] + ", "
                                + values[5] + ", " + values[6] + ", " + values[7] + ", " + values[8] +
                                "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];
                }

                /* Если строка напоминает правило с одним целочисленным значением и после текстового ограничения неверно стоит запятая
                (частая ошибка, есть смысл выделить в отдельную проверку)*/
                if(strOneRule[i].contains("в составе которого есть значение") && (!strOneRule[i][strOneRule[i].lastIndexOf(",") + 1].isSpace()
                                                                                  || strOneRule[i][strOneRule[i].lastIndexOf(",") - 1] != "\""))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nПосле текстового ограничения должна стоять запятая и пробел \', \'."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                // Если строка напоминает правило с одним целочисленным значением и между последними двоными кавычками нет ничего
                if(strOneRule[i].contains("в составе которого есть значение") && strOneRule[i][strOneRule[i].lastIndexOf("\"") - 1] == "\"")
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nПоле дополнительного ограничения не должно быть пустым. Внутри двойных кавычек должно быть одно число от 1 до 99."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i];

                QString delSpaseStr = strOneRule[i]; // создаём строку теста правила
                delSpaseStr.remove(' '); // удаляем все пробелы

                // Если строка напоминает правило с массивом целочисленных значений
                if(delSpaseStr.contains("изначениеэтогосвойстваравно"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде конкретных целочисленных значений. "
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\nПравильный формат:"
                            "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<текстовое ограничение>\" и значение этого свойства равно \"[<целочисленные значения через ','>]\"";

                // Иначе если строка напонимает правило с количеством целочисленных значений
                else if(delSpaseStr.contains("котороепредставлено"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде количества целочисленных значений."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\n\nПравильный формат:"
                            "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<текстовое ограничение>\", которое представлено <кол-во значений в виде текста> значением(ями)";

                // Иначе если строка напоминает правило с одним целочисленным значением
                else if(delSpaseStr.contains("всоставекоторогоестьзначение"))
                    return "Ошибка! Неверный формат ввода дополнительного ограничения в виде одного целочисленного значения. "
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\n\nПравильный формат:"
                            "\nЗапись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"";

                // Если строка содержит не 4 двойных кавычек
                if(strOneRule[i].count("\"") != 4)
                    return "Ошибка! Неверный формат ввода правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\n\nДопустимые форматы: "
                            "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                            "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                            "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                            "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'"; //символов " должно быть 4

                // Если не последняя строка не заканчивается двойной кавычкой
                if(strOneRule[i].lastIndexOf("\"") + 1 != strOneRule[i].count() && strOneRule[i].count(".") == 0)
                    return "Ошибка! Неверный формат ввода правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\n\nДопустимые форматы: "
                            "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                            "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                            "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                            "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'";

                // Если последняя строка не заканчивается двойной кавычкой
                if(strOneRule[i].count(".") == 1 && strOneRule[i][strOneRule[i].lastIndexOf("\"") + 1] != ".")
                    return "Ошибка! Неверный формат ввода правила."
                           "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                            "\n\nДопустимые форматы: "
                            "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                            "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                            "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                            "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'";
            }
            numberRuleName.append(substrings[0]); // добавляем название класса для последующей проверки на совпадения
        }
        // Если ни один из паттернов не подошёл то выводим сообщение об ошибке
        else
            return "Ошибка! Неверный формат ввода правила."
                   "\nОшибка в правиле " + QString::number(i + 1) + ": " + strOneRule[i] +
                    "\n\nДопустимые форматы: "
                    "\n1) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\"'"
                    "\n2) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", которое представлено ([одним|двумя|тремя|четырьмя|пятью|шестью|семью|восемью|девятью]) значением(ями)'"
                    "\n3) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\", в составе которого есть значение \"<одно целочисленное значение>\"'"
                    "\n4) 'Запись принадлежит классу \"<название класса>\", если у нее есть свойство \"<название свойства>\" и значение этого свойства равно \"[целочисленные значения через ',']\"'";
    }

    //-------------------------------Блок проверки на совпадения названий классов--------------------------------------------------
    // Для каджого названия класса
    for (int i = 0; i < numberRuleName.count(); ++i)
    {
        const QString& currentString = numberRuleName[i]; // создаём неизменяемую строку в которую присваиваем текущее название класса (i)

        // Для каждого названия класса, идущего после текущего
        for (int j = i + 1; j < numberRuleName.count(); ++j)
        {
            const QString& otherString = numberRuleName[j]; // создаём неизменяемую строку в которую присваиваем текущее название класса (j)

            // Если названия классов совпали
            if (currentString == otherString)
                return "Ошибка! Названия классов не могут повторяться."
                       "\nНазвание класса: \"" + currentString + "\""
                                                                 "\nПовторение в правилах: " + QString::number(i + 1) + " и " + QString::number(j + 1);
        }
    }
    //-----------------------------------------------------------------------------------------------------------------------------

    //---------------------------------Блок проверки на совпадения ограничений правил классификации--------------------------------
    // Для каждого правила
    for(int i = 0; i < strOneRule.count(); ++i)
    {
        // создаём строку и присваиваем ему подстроку следующую после названия класса (i)
        QString currentString = strOneRule[i].mid(strOneRule[i].indexOf("\"", 29) + 1);
        currentString.remove(" "); // удаляем из созданной строки все пробелы

        // Если есть точка в подстроке, удаляем её
        if(currentString.count(".") != 0)
            currentString.remove(".");

        // Для каждого правила следующего после текущего
        for(int j = i + 1; j < strOneRule.count(); ++j)
        {
            // создаём строку и присваиваем ему подстроку следующую после названия класса (j)
            QString otherString = strOneRule[j].mid(strOneRule[j].indexOf("\"", 29) + 1);
            otherString.remove(" "); // удаляем из созданной строки все пробелы

            // Если есть точка в подстроке, удаляем её
            if(otherString.count(".") != 0)
                otherString.remove(".");

            // Если ограничения правил совпали
            if (currentString == otherString)
                return "Ошибка! Условия классификации не могут повторяться."
                       "\nУсловие классификации: \"" + strOneRule[i].mid(strOneRule[i].indexOf("\"", 29) + 3) + "\""
                                                                                                                "\nПовторение в правилах: " + QString::number(i + 1) + " и " + QString::number(j + 1);
        }
    }
    //------------------------------------------------------------------------------------------------------------------------------

    // Весь текст правил классификации прошёл проверку, вернуть "Всё хорошо!"
    return "Всё хорошо!";
}

ConditionType ClassificationRules::getCondition()
{
    return this -> condition; // вернуть текущее значение типа правила
}

LimitationIntegerValues ClassificationRules::getLimitValue()
{
    return this -> limitValue; // вернуть текущее значение количества целочисленных значений заданных в оганичении
}

QString ClassificationRules::getName()
{
    return this -> name; // вернуть текущее имя класса
}

QString ClassificationRules::getConstraint()
{
    return this -> constraint; // вернуть текущее название текстового ограничения
}

QList<int> ClassificationRules::getIntegerValues()
{
    return this -> integerValues; // вернуть текущие значения дополнительного ограничения в виде целочисленных значений
}
